"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2889],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>d});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=c(r),d=a,g=m["".concat(l,".").concat(d)]||m[d]||p[d]||s;return r?n.createElement(g,o(o({ref:t},u),{},{components:r})):n.createElement(g,o({ref:t},u))}));function d(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=r.length,o=new Array(s);o[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var c=2;c<s;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},8485:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var n=r(7462),a=(r(7294),r(3905));const s={sidebar_position:1,sidebar_label:"K8s Storage"},o="K8s Storage",i={unversionedId:"terms/k8s_storage",id:"terms/k8s_storage",title:"K8s Storage",description:"Kubernetes has made several enhancements to support running Stateful Workloads",source:"@site/docs/terms/k8s_storage.md",sourceDirName:"terms",slug:"/terms/k8s_storage",permalink:"/docs/terms/k8s_storage",draft:!1,editUrl:"https://github.com/hwameistor/hwameistor/edit/main/docs/docs/terms/k8s_storage.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"K8s Storage"},sidebar:"tutorialSidebar",previous:{title:"Terminologies",permalink:"/docs/category/terminologies"},next:{title:"CAS",permalink:"/docs/terms/cas"}},l={},c=[{value:"Container Storage Interface",id:"container-storage-interface",level:2},{value:"Storage Classes and Dynamic Provisioning",id:"storage-classes-and-dynamic-provisioning",level:2},{value:"Persistent Volume Claims",id:"persistent-volume-claims",level:2},{value:"Persistent Volume",id:"persistent-volume",level:2},{value:"StatefulSets and Deployments",id:"statefulsets-and-deployments",level:2}],u={toc:c};function p(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"k8s-storage"},"K8s Storage"),(0,a.kt)("p",null,"Kubernetes has made several enhancements to support running Stateful Workloads\nby providing the required abstractions for Platform (or Cluster Administrators)\nand Application developers. The abstractions ensure that different types of file\nand block storage (whether ephemeral or persistent, local or remote) are available\nwherever a container is scheduled (including provisioning/creating, attaching,\nmounting, unmounting, detaching, and deleting of volumes), storage capacity management\n(container ephemeral storage usage, volume resizing, etc.), influencing scheduling of\ncontainers based on storage (data gravity, availability, etc.), and generic operations\non storage (snapshotting, etc.)."),(0,a.kt)("p",null,"The most important Kubernetes Storage abstractions to be aware of for running Stateful\nworkloads using HwameiStor are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#kubernetes-storage"},"Kubernetes Storage"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#container-storage-interface"},"Container Storage Interface")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#storage-classes-and-dynamic-provisioning"},"Storage Classes and Dynamic Provisioning")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#persistent-volume-claims"},"Persistent Volume Claims")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#persistent-volume"},"Persistent Volume")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#statefulsets-and-deployments"},"StatefulSets and Deployments"))))),(0,a.kt)("h2",{id:"container-storage-interface"},"Container Storage Interface"),(0,a.kt)("p",null,"The Container Storage Interface (CSI) is a standard for exposing arbitrary block and\nfile storage systems to containerized workloads on Container Orchestration Systems (COs)\nlike Kubernetes. Using CSI third-party storage providers like HwameiStor can write and\ndeploy plugins exposing new storage volumes like HwameiStor Local and Replicated Volumes\nin Kubernetes without ever having to touch the core Kubernetes code."),(0,a.kt)("p",null,"When cluster administrators install HwameiStor, the required HwameiStor CSI driver\ncomponents are installed into the Kubernetes cluster."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"Prior to CSI, Kubernetes supported adding storage providers using out-of-tree provisioners referred to as external provisioners. And Kubernetes in-tree volumes pre-date the external provisioners. There is an ongoing effort in the Kubernetes community to deprecate in-tree volumes with CSI based volumes.\n")),(0,a.kt)("h2",{id:"storage-classes-and-dynamic-provisioning"},"Storage Classes and Dynamic Provisioning"),(0,a.kt)("p",null,'A StorageClass provides a way for administrators to describe the "classes" of storage\nthey offer. Different classes might map to quality-of-service levels, or to backup\npolicies, or to arbitrary policies determined by the cluster administrators. This\nconcept is sometimes called "profiles" in other storage systems.'),(0,a.kt)("p",null,"The dynamic provisioning feature eliminates the need for cluster administrators\nto pre-provision storage. Instead, it automatically provisions storage when it\nis requested by users. The implementation of dynamic volume provisioning is based\non the StorageClass abstraction. A cluster administrator can define as many\nStorageClass objects as needed, each specifying a volume plugin (aka provisioner)\nthat provisions a volume and the set of parameters to pass to that provisioner when provisioning."),(0,a.kt)("p",null,"A cluster administrator can define and expose multiple flavors of storage\n(from the same or different storage systems) within a cluster, each with a custom\nset of parameters. This design also ensures that end users don't have to worry about\nthe complexity and nuances of how storage is provisioned, but still have the ability\nto select from multiple storage options."),(0,a.kt)("p",null,"When HwameiStor is installed, it ships with a couple of default storage classes that\nallow users to create either local (HwameiStor LocalVolume) or replicated\n(HwameiStor LocalVolumeReplica) volumes. The cluster administrator can enable the\nrequired storage engines and then create Storage Classes for the required Data Engines."),(0,a.kt)("h2",{id:"persistent-volume-claims"},"Persistent Volume Claims"),(0,a.kt)("p",null,"PersistentVolumeClaim (PVC) is a user\u2019s storage request that is served by a StorageClass\noffered by the cluster administrator. An application running on a container can request\na certain type of storage. For example, a container can specify the size of storage it\nneeds or the way it needs to access the data (read only, read/write, read-write many, etc.,)."),(0,a.kt)("p",null,"Beyond storage size and access mode, administrators create Storage Classes to provided PVs\nwith custom properties, such as the type of disk (HDD vs. SSD), the level of performance,\nor the storage tier (regular or cold storage)."),(0,a.kt)("h2",{id:"persistent-volume"},"Persistent Volume"),(0,a.kt)("p",null,"The PersistentVolume(PV) is dynamically provisioned by the storage providers when users\nrequest for a PVC. PV contains the details on how the storage can be consumed by the\ncontainer. Kubernetes and the Volume Drivers use the details in the PV to attach/detach\nthe storage to the node where the container is running and mount/unmount storage to a container."),(0,a.kt)("p",null,"HwameiStor Control Plane dynamically provisions HwameiStor Local and Replicated volumes\nand helps in creating the PV objects in the cluster."),(0,a.kt)("h2",{id:"statefulsets-and-deployments"},"StatefulSets and Deployments"),(0,a.kt)("p",null,"Kubernetes provides several built-in workload resources such as StatefulSets and Deployments\nthat let application developers define an application running on Kubernetes. You can run a\nstateful application by creating a Kubernetes Deployment/Statefulset and connecting it to\na PersistentVolume using a PersistentVolumeClaim."),(0,a.kt)("p",null,"For example, you can create a MySQL Deployment YAML that references a PersistentVolumeClaim.\nThe MySQL PersistentVolumeClaim referenced by the Deployment should be created with the\nrequested size and StorageClass. Once the HwameiStor control plane provisions a PersistenceVolume\nfor the required StorageClass and requested capacity, the claim is set as satisfied. Kubernetes\nwill then mount the PersistentVolume and launch the MySQL Deployment."))}p.isMDXComponent=!0}}]);