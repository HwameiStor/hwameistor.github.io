"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4454],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>d});var n=r(7294);function s(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){s(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,s=function(e,t){if(null==e)return{};var r,n,s={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(s[r]=e[r]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(s[r]=e[r])}return s}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,s=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=l(r),d=s,f=m["".concat(c,".").concat(d)]||m[d]||p[d]||o;return r?n.createElement(f,a(a({ref:t},u),{},{components:r})):n.createElement(f,a({ref:t},u))}));function d(e,t){var r=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=r.length,a=new Array(o);a[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:s,a[1]=i;for(var l=2;l<o;l++)a[l]=r[l];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},1245:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var n=r(7462),s=(r(7294),r(3905));const o={sidebar_position:7,sidebar_label:"PV and PVC"},a="PV and PVC",i={unversionedId:"terms/pv_pvc",id:"terms/pv_pvc",title:"PV and PVC",description:"The PersistentVolume subsystem provides an API for users and administrators that",source:"@site/docs/terms/pv_pvc.md",sourceDirName:"terms",slug:"/terms/pv_pvc",permalink:"/docs/terms/pv_pvc",draft:!1,editUrl:"https://github.com/hwameistor/hwameistor/edit/main/docs/docs/terms/pv_pvc.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,sidebar_label:"PV and PVC"},sidebar:"tutorialSidebar",previous:{title:"LVM",permalink:"/docs/terms/lvm"},next:{title:"Community",permalink:"/docs/community"}},c={},l=[],u={toc:l};function p(e){let{components:t,...r}=e;return(0,s.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"pv-and-pvc"},"PV and PVC"),(0,s.kt)("p",null,"The PersistentVolume subsystem provides an API for users and administrators that\nabstracts details of how storage is provided from how it is consumed. To do this,\nwe introduce two new API resources: PersistentVolume (PV) and PersistentVolumeClaim (PVC).\nA PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by\nan administrator or dynamically provisioned using Storage Classes. It is a resource in\nthe cluster just like a node is a cluster resource. PVs are volume plugins like Volumes,\nbut have a lifecycle independent of any individual Pod that uses the PV. This API object\ncaptures the details of the implementation of the storage, be that NFS, iSCSI, or a\ncloud-provider-specific storage system."),(0,s.kt)("p",null,"A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod.\nPods consume node resources and PVCs consume PV resources. Pods can request specific levels\nof resources (CPU and Memory). Claims can request specific size and access modes\n(e.g., they can be mounted ReadWriteOnce, ReadOnlyMany or ReadWriteMany, see AccessModes)."),(0,s.kt)("p",null,"While PersistentVolumeClaims allow a user to consume abstract storage resources, it is\ncommon that users need PersistentVolumes with varying properties, such as performance,\nfor different problems. Cluster administrators need to be able to offer a variety of\nPersistentVolumes that differ in more ways than size and access modes, without exposing\nusers to the details of how those volumes are implemented. For these needs, there is\nthe StorageClass resource. It is used to mark storage resources and performance, and\ndynamically provision appropriate PV resources based on PVC demand. After the mechanism\nof StorageClass and dynamic provisioning developed for storage resources, the on-demand\ncreation of volumes is realized, which is an important step in the automatic management\nprocess of shared storage."),(0,s.kt)("p",null,"See also the official documentation provided by Kubernetes:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/"},"Persistent Volume")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://kubernetes.io/docs/concepts/storage/storage-classes/"},"StorageClass")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/"},"Dynamic Volume Provisioning"))))}p.isMDXComponent=!0}}]);