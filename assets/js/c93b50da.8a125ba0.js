"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[815],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>p});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),c=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),h=c(a),p=n,m=h["".concat(l,".").concat(p)]||h[p]||u[p]||o;return a?r.createElement(m,s(s({ref:t},d),{},{components:a})):r.createElement(m,s({ref:t},d))}));function p(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,s=new Array(o);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:n,s[1]=i;for(var c=2;c<o;c++)s[c]=a[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,a)}h.displayName="MDXCreateElement"},3058:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=a(7462),n=(a(7294),a(3905));const o={sidebar_position:2,sidebar_label:"CAS"},s="CAS",i={unversionedId:"terms/cas",id:"terms/cas",title:"CAS",description:"Container Attached Storage (CAS) is software that includes microservice based storage",source:"@site/docs/terms/cas.md",sourceDirName:"terms",slug:"/terms/cas",permalink:"/docs/terms/cas",draft:!1,editUrl:"https://github.com/hwameistor/hwameistor/docs/terms/cas.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"CAS"},sidebar:"tutorialSidebar",previous:{title:"K8s Storage",permalink:"/docs/terms/k8s_storage"},next:{title:"CSI",permalink:"/docs/terms/csi"}},l={},c=[{value:"Advantages of CAS",id:"advantages-of-cas",level:2},{value:"Agility",id:"agility",level:3},{value:"Granularity of Storage Policies",id:"granularity-of-storage-policies",level:3},{value:"Avoid Lock-in",id:"avoid-lock-in",level:3},{value:"Cloud Native",id:"cloud-native",level:3},{value:"Lower Blast Radius",id:"lower-blast-radius",level:3}],d={toc:c};function u(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"cas"},"CAS"),(0,n.kt)("p",null,"Container Attached Storage (CAS) is software that includes microservice based storage\ncontrollers that are orchestrated by Kubernetes. These storage controllers can run\nanywhere that Kubernetes can run which means any cloud or even bare metal server or\non top of a traditional shared storage system. Critically, the data itself is also\naccessed via containers as opposed to being stored in an off platform shared scale\nout storage system. Because CAS leverages a microservices architecture, it keeps the\nstorage solution closely tied to the application bound to the physical storage device,\nreducing I/O latency."),(0,n.kt)("p",null,"CAS is a pattern very much in line with the trend towards disaggregated data and the\nrise of small, autonomous teams running small, loosely coupled workloads. For example,\nmy team might need Postgres for our microservice, and yours might depend on Redis and\nMongoDB. Some of our use cases might require performance, some might be gone in 20 minutes,\nothers are write intensive, others read intensive, and so on. In a large organization,\nthe technology that teams depend on will vary more and more as the size of the organization\ngrows and as organizations increasingly trust teams to select their own tools."),(0,n.kt)("p",null,"CAS means that developers can work without worrying about the underlying requirements of\ntheir organizations' storage architecture. To CAS, a cloud disk is the same as a SAN which\nis the same as bare metal or virtualized hosts. Developers and Platform SREs don\u2019t have\nmeetings to select the next storage vendor or to argue for settings to support their use\ncase, instead Developers remain autonomous and can spin up their own CAS containers with\nwhatever storage is available to the Kubernetes clusters."),(0,n.kt)("p",null,"CAS reflects a broader trend of solutions \u2013 many of which are now part of Cloud Native\nFoundation \u2013 that reinvent particular categories or create new ones \u2013 by being built on\nKubernetes and microservice and that deliver capabilities to Kubernetes based microservice\nenvironments. For example, new projects for security, DNS, networking, network policy\nmanagement, messaging, tracing, logging and more have emerged in the cloud-native ecosystem\nand often in CNCF itself."),(0,n.kt)("h2",{id:"advantages-of-cas"},"Advantages of CAS"),(0,n.kt)("h3",{id:"agility"},"Agility"),(0,n.kt)("p",null,"Each storage volume in CAS has a containerized storage controller and corresponding\ncontainerized replicas. Hence, maintenance and tuning of the resources around these\ncomponents are truly agile. The capability of Kubernetes for rolling upgrades enables\nseamless upgrades of storage controllers and storage replicas. Resources such as CPU\nand memory can be tuned using container cgroups."),(0,n.kt)("h3",{id:"granularity-of-storage-policies"},"Granularity of Storage Policies"),(0,n.kt)("p",null,"Containerizing the storage software and dedicating the storage controller to each\nvolume brings maximum granularity in storage policies. With CAS architecture, you\ncan configure all storage policies on a per-volume basis. In addition, you can\nmonitor storage parameters of every volume and dynamically update storage policies\nto achieve the desired result for each workload. The control of storage throughput,\nIOPS, and latency increases with this additional level of granularity in the volume\nstorage policies."),(0,n.kt)("h3",{id:"avoid-lock-in"},"Avoid Lock-in"),(0,n.kt)("p",null,"Avoiding cloud vendor lock-in is a common goal for many Kubernetes users. However,\nthe data of stateful applications often remains dependent on the cloud provider and\ntechnology or on an underlying traditional shared storage system, NAS or SAN. With\nthe CAS approach, storage controllers can migrate the data in the background per\nworkload and live migration becomes simpler. In other words, the granularity of\ncontrol of CAS simplifies the movement of stateful workloads from one Kubernetes\ncluster to another in a non-disruptive way."),(0,n.kt)("h3",{id:"cloud-native"},"Cloud Native"),(0,n.kt)("p",null,"CAS containerizes the storage software and uses Kubernetes Custom Resource Definitions (CRDs)\nto represent low-level storage resources, such as disks and storage pools. This model enables\nstorage to be integrated into other cloud-native tools seamlessly. The storage resources can\nbe provisioned, monitored, and managed using cloud-native tools such as Prometheus, Grafana,\nFluentd, Weavescope, Jaeger, and others."),(0,n.kt)("p",null,"Similar to hyperconverged systems, storage and performance of a volume in CAS are scalable.\nAs each volume has it's own storage controller, the storage can scale up within the permissible\nlimits of a storage capacity of a node. As the number of container applications increases in\na given Kubernetes cluster, more nodes are added, which increases the overall availability of\nstorage capacity and performance, thereby making the storage available to the new application containers."),(0,n.kt)("h3",{id:"lower-blast-radius"},"Lower Blast Radius"),(0,n.kt)("p",null,"Because the CAS architecture is per workload and components are loosely coupled, CAS has a much\nsmaller blast radius than a typical distributed storage architecture."),(0,n.kt)("p",null,"CAS can deliver high availability through synchronous replication from storage controllers to\nstorage replicas. The metadata required to maintain the replicas is simplified to store the\ninformation of the nodes that have replicas and information about the status of replicas to\nhelp with quorum. If a node fails, the storage controller, which is a stateless container in\nthis case, is spun on a node where second or third replica is running and data continues to be\navailable. Hence, with CAS the blast radius is much lower and also localized to the volumes that\nhave replicas on that node."))}u.isMDXComponent=!0}}]);